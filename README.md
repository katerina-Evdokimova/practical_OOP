# Практические задачи по ООП(С++).

Решение задач по ООП 1 курса 2 семестра.

## Практика 1

[Практика 1](https://github.com/katerina-Evdokimova/practical_OOP/blob/main/Practical_1.cpp)
Изучена перегрузка операций.
Сложение с вектором из 3 компонент, вычитание двух точек - вектор.

```Cpp

class Vector
{
protected:
	
	double x;
	double y;
	double z;
public:
	
	Vector() { x = 0; y = 0; z = 0; }
	Vector(double X) { x = X; y = 0; z = 0; }
	Vector(double X, double Y) { x = X; y = Y; z = 0; }
	Vector(double X, double Y, double Z) { x = X; y = Y; z = Z; }
	Vector(Vector& F) { x = F.x; y = F.y; z = F.z; }
	
	~Vector() { cout << "Destructor is working" << endl; }

	Vector operator+(Vector F)
	{
		Vector Res;
		Res.x = x + F.x;
		Res.y = y + F.y;
		Res.z = z + F.z;

		return Res;
	}

	Vector operator-(Vector F) 
	{
		Vector Res;
		Res.x = x - F.x;
		Res.y = y - F.y;
		Res.z = z - F.z;
		return Res;
	}
	void print()
	{
		std::cout <<"{ "<< x << ", " << y << ", " << z << " }" << endl;
	}
};

class Vector_Child : public Vector
{
public:

	Vector_Child() : Vector() {}
	Vector_Child(double X) : Vector(X){}
	Vector_Child(double X, double Y) : Vector(X, Y) {}
	Vector_Child(double X, double Y, double Z) : Vector(X, Y, Z){}
	Vector_Child(Vector& F) : Vector(F) {}

	~Vector_Child() { cout << "\nVector_Child destructor\n"; }

	Vector_Child operator+(Vector_Child F)
	{
		Vector_Child Res;
		Res.x = x + F.x;
		Res.y = y + F.y;
		Res.z = z + F.z;

		return Res;
	}

	Vector_Child operator-(Vector_Child F)
	{	
		Vector_Child Res;
		Res.x = x - F.x;
		Res.y = y - F.y;
		Res.z = z - F.z;
		return Res;
	}
	

	friend Vector_Child operator+(int a, Vector_Child F);
	friend Vector_Child operator+(Vector_Child F, int a);

	
};

Vector_Child operator+(Vector_Child F, int a)
{
	Vector_Child Res;
	Res.x = a + F.x;
	Res.y = a + F.y;
	Res.z = a + F.z;

	return Res;

}
Vector_Child operator+(int a, Vector_Child F)
{
	Vector_Child Res;
	Res.x = a + F.x;
	Res.y = a + F.y;
	Res.z = a + F.z;

	return Res;

}
```
## Практика 2

Реализовае бинарный поиск и поиск по индексу.

[Практика 2](https://github.com/katerina-Evdokimova/practical_c-/blob/main/Practical_2.cpp)

## Практика 3

Реализовать указанная схема наследования. В схеме «0» А1 –
родитель для классов B1, B2.

-1. Каждый класс содержит защищённую переменную. Каждый класс имеет конструктор, присваивающий этой переменной некое значение. Конструкторы производных классов должны вызывают конструкторы базовых классов и передают туда параметры.
-2. В базовых классах реализована функция print(), которая выводит на консоль имя класса, из которого она вызвана. В производных классах она переопределена и выводит корректный результат.
	-Например:
		A1 a;
		a.print(); => “A1”
		B1 b;
		b.print(); => “B1”
-3. Написана функция show(), которая выводит все доступные для этого класса переменные.

	-[Практика 3](https://github.com/katerina-Evdokimova/practical_OOP/blob/main/Practical_3.cpp)

![](https://sun9-20.userapi.com/impg/jJaWEDUd17y5fzsy1I2tkH84kgwKLTVHERXZXw/N9qxrxj67IU.jpg?size=649x622&quality=96&sign=86febb1c61f96121d838fab3e53b2022&type=album "Орк")

## Практика 4

Унаследован класс от базового класса «Строка». Реализованы работы функций:
конструкторов, конструктора копий, деструктора, operator=, как в базовом классе, так и в
наследнике. Написана функция, вводящую аналог операции “<” для сравнения двух строк
(сравнение в алфавитном порядке).

[Практика 4](https://github.com/katerina-Evdokimova/practical_OOP/blob/main/Practical_4.cpp)

## Практика 5

-1.Унаследован класс от базового класса Многомерныймассив. Убедилась, что в родительском классе верно выделяется и освобождается память под многомерный массив. В производном классе написан метод заполнения массива произвольным нетривиальным образом. Введите метод, который решает задачу: Считая каждый столбец матрицы вектором, получить новую матрицу, в которой столбцы отсортированы по евклидовой норме.

-2. Введите систему исключений.

-3. Сохранен результат обработки нескольких матриц в файл, извлекли
результаты из файла, вывели их в консоль. Продемонстрировали, что результаты, которые записывались в файл, и прочитанные из файла данные не отличаются.
-4. Введены конструкторы и методы для чтения матрицы произвольного размера из файла.
-5. Преобразованы классы многомерных массивов к шаблонам классов.

[Практика 5](https://github.com/katerina-Evdokimova/practical_OOP/blob/main/Practical_5.cpp)

## Практика 6

-1. Реализована структура для хранения представленных данных (класс,
представляющий Связный список, является шаблоном класса, в main его работа
демонстрируется на примере хранения объекта структуры/класса из Вашего варианта): 
	-Структура «Школьник».
	-Минимальный набор полей: фамилия, имя, пол, класс, дата рождения, адрес.
	-Добавление: в начало
	-Удаление: с конца
	-Поиск по фамилии, фильтр по классу.
Информация в элемен структуры вводится со стандартного потока ввода.(предусмотрено автоматическое заполнение).

-2. В классе Связный Список введен деструктор. Поля класса должны быть защищены (protected). Введен открытый интерфейс (public) для работы с ними. Унаследован класс списка от базового класса Связный список с ключевым словом public. Переопределены функции push() и pop() – для добавления и извлечения элементов из списка. Написаны функции вставки нового элемента в произвольное место списка insert(), удаления remove(), поиска элемента find() по значению. Реализован указанный вид поиска: под функцией фильтра предполагается поиск элементов, которые удовлетворяют условию element.field>, < value, под поиском – только element.info==value (element.info – поле info в элементе списка element, value – искомое значение). Фильтр возвращает новый список элементов, удовлетворяющих условию. Функцию фильтра и поиска реализованы в итеративной и рекурсивной формах. 


-3*. Кроме фильтра по указанным полям, написан универсальный фильтр по произвольному полю, который принимает указатель на функцию. Эта функция возвращает 1, если элемент удовлетворяет условию и 0 – в противном случае.

-4. Выделена память для списка динамически (используя указатель на базовый класс), а затем, в конце работы кода, освобождена. Проверена правильность работы деструкторов базового и производного классов (использован виртуальный деструктор). Преобразован указатель на базовый класс в указатель типа производного класса с помощью оператора dynamic_cast. Проверена работа деструкторо в случае выполнения операции освобождения памяти для преобразованного указателя.

-5. Написана функции сохранения списка файл* save() и извлечения списка из файла* load(). Для ввода/вывода элемента списка в/из файла используованы переопределённые функции ввода/вывода в поток (сделано различие между вводом/выводом в консоль и вводом/выводом в файл).
-6. Введен манипулятор, форматирующий вывод, и применили его при выводе содержимого контейнера: Вывод в 8-ричной системе счисления, выравнивание по левому краю.

[Практика 6](https://github.com/katerina-Evdokimova/practical_OOP/blob/main/Practical_6.cpp)
